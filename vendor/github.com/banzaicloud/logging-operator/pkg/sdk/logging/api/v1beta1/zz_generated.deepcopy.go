//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Copyright Â© 2020 Banzai Cloud
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by controller-gen. DO NOT EDIT.

package v1beta1

import (
	"github.com/banzaicloud/logging-operator/pkg/sdk/logging/model/filter"
	"github.com/banzaicloud/logging-operator/pkg/sdk/logging/model/input"
	"github.com/banzaicloud/logging-operator/pkg/sdk/logging/model/output"
	syslogngfilter "github.com/banzaicloud/logging-operator/pkg/sdk/logging/model/syslogng/filter"
	syslogngoutput "github.com/banzaicloud/logging-operator/pkg/sdk/logging/model/syslogng/output"
	"github.com/banzaicloud/operator-tools/pkg/typeoverride"
	"github.com/banzaicloud/operator-tools/pkg/volume"
	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BufferMetrics) DeepCopyInto(out *BufferMetrics) {
	*out = *in
	in.Metrics.DeepCopyInto(&out.Metrics)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BufferMetrics.
func (in *BufferMetrics) DeepCopy() *BufferMetrics {
	if in == nil {
		return nil
	}
	out := new(BufferMetrics)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BufferStorage) DeepCopyInto(out *BufferStorage) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BufferStorage.
func (in *BufferStorage) DeepCopy() *BufferStorage {
	if in == nil {
		return nil
	}
	out := new(BufferStorage)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterExclude) DeepCopyInto(out *ClusterExclude) {
	*out = *in
	if in.Namespaces != nil {
		in, out := &in.Namespaces, &out.Namespaces
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ContainerNames != nil {
		in, out := &in.ContainerNames, &out.ContainerNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterExclude.
func (in *ClusterExclude) DeepCopy() *ClusterExclude {
	if in == nil {
		return nil
	}
	out := new(ClusterExclude)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterFlow) DeepCopyInto(out *ClusterFlow) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterFlow.
func (in *ClusterFlow) DeepCopy() *ClusterFlow {
	if in == nil {
		return nil
	}
	out := new(ClusterFlow)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterFlow) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterFlowList) DeepCopyInto(out *ClusterFlowList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClusterFlow, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterFlowList.
func (in *ClusterFlowList) DeepCopy() *ClusterFlowList {
	if in == nil {
		return nil
	}
	out := new(ClusterFlowList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterFlowList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterFlowSpec) DeepCopyInto(out *ClusterFlowSpec) {
	*out = *in
	if in.Selectors != nil {
		in, out := &in.Selectors, &out.Selectors
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Match != nil {
		in, out := &in.Match, &out.Match
		*out = make([]ClusterMatch, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]Filter, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OutputRefs != nil {
		in, out := &in.OutputRefs, &out.OutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.GlobalOutputRefs != nil {
		in, out := &in.GlobalOutputRefs, &out.GlobalOutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterFlowSpec.
func (in *ClusterFlowSpec) DeepCopy() *ClusterFlowSpec {
	if in == nil {
		return nil
	}
	out := new(ClusterFlowSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterMatch) DeepCopyInto(out *ClusterMatch) {
	*out = *in
	if in.ClusterSelect != nil {
		in, out := &in.ClusterSelect, &out.ClusterSelect
		*out = new(ClusterSelect)
		(*in).DeepCopyInto(*out)
	}
	if in.ClusterExclude != nil {
		in, out := &in.ClusterExclude, &out.ClusterExclude
		*out = new(ClusterExclude)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterMatch.
func (in *ClusterMatch) DeepCopy() *ClusterMatch {
	if in == nil {
		return nil
	}
	out := new(ClusterMatch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterOutput) DeepCopyInto(out *ClusterOutput) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterOutput.
func (in *ClusterOutput) DeepCopy() *ClusterOutput {
	if in == nil {
		return nil
	}
	out := new(ClusterOutput)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterOutput) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterOutputList) DeepCopyInto(out *ClusterOutputList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClusterOutput, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterOutputList.
func (in *ClusterOutputList) DeepCopy() *ClusterOutputList {
	if in == nil {
		return nil
	}
	out := new(ClusterOutputList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterOutputList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterOutputSpec) DeepCopyInto(out *ClusterOutputSpec) {
	*out = *in
	in.OutputSpec.DeepCopyInto(&out.OutputSpec)
	if in.EnabledNamespaces != nil {
		in, out := &in.EnabledNamespaces, &out.EnabledNamespaces
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterOutputSpec.
func (in *ClusterOutputSpec) DeepCopy() *ClusterOutputSpec {
	if in == nil {
		return nil
	}
	out := new(ClusterOutputSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterSelect) DeepCopyInto(out *ClusterSelect) {
	*out = *in
	if in.Namespaces != nil {
		in, out := &in.Namespaces, &out.Namespaces
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ContainerNames != nil {
		in, out := &in.ContainerNames, &out.ContainerNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterSelect.
func (in *ClusterSelect) DeepCopy() *ClusterSelect {
	if in == nil {
		return nil
	}
	out := new(ClusterSelect)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DefaultFlowSpec) DeepCopyInto(out *DefaultFlowSpec) {
	*out = *in
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]Filter, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OutputRefs != nil {
		in, out := &in.OutputRefs, &out.OutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.GlobalOutputRefs != nil {
		in, out := &in.GlobalOutputRefs, &out.GlobalOutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DefaultFlowSpec.
func (in *DefaultFlowSpec) DeepCopy() *DefaultFlowSpec {
	if in == nil {
		return nil
	}
	out := new(DefaultFlowSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Exclude) DeepCopyInto(out *Exclude) {
	*out = *in
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ContainerNames != nil {
		in, out := &in.ContainerNames, &out.ContainerNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Exclude.
func (in *Exclude) DeepCopy() *Exclude {
	if in == nil {
		return nil
	}
	out := new(Exclude)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ExtraVolume) DeepCopyInto(out *ExtraVolume) {
	*out = *in
	if in.Volume != nil {
		in, out := &in.Volume, &out.Volume
		*out = new(volume.KubernetesVolume)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExtraVolume.
func (in *ExtraVolume) DeepCopy() *ExtraVolume {
	if in == nil {
		return nil
	}
	out := new(ExtraVolume)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Filter) DeepCopyInto(out *Filter) {
	*out = *in
	if in.StdOut != nil {
		in, out := &in.StdOut, &out.StdOut
		*out = new(filter.StdOutFilterConfig)
		**out = **in
	}
	if in.Parser != nil {
		in, out := &in.Parser, &out.Parser
		*out = new(filter.ParserConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.TagNormaliser != nil {
		in, out := &in.TagNormaliser, &out.TagNormaliser
		*out = new(filter.TagNormaliser)
		**out = **in
	}
	if in.Dedot != nil {
		in, out := &in.Dedot, &out.Dedot
		*out = new(filter.DedotFilterConfig)
		**out = **in
	}
	if in.ElasticGenId != nil {
		in, out := &in.ElasticGenId, &out.ElasticGenId
		*out = new(filter.ElasticsearchGenId)
		**out = **in
	}
	if in.RecordTransformer != nil {
		in, out := &in.RecordTransformer, &out.RecordTransformer
		*out = new(filter.RecordTransformer)
		(*in).DeepCopyInto(*out)
	}
	if in.RecordModifier != nil {
		in, out := &in.RecordModifier, &out.RecordModifier
		*out = new(filter.RecordModifier)
		(*in).DeepCopyInto(*out)
	}
	if in.GeoIP != nil {
		in, out := &in.GeoIP, &out.GeoIP
		*out = new(filter.GeoIP)
		(*in).DeepCopyInto(*out)
	}
	if in.Concat != nil {
		in, out := &in.Concat, &out.Concat
		*out = new(filter.Concat)
		**out = **in
	}
	if in.DetectExceptions != nil {
		in, out := &in.DetectExceptions, &out.DetectExceptions
		*out = new(filter.DetectExceptions)
		(*in).DeepCopyInto(*out)
	}
	if in.Grep != nil {
		in, out := &in.Grep, &out.Grep
		*out = new(filter.GrepConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.Prometheus != nil {
		in, out := &in.Prometheus, &out.Prometheus
		*out = new(filter.PrometheusConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.Throttle != nil {
		in, out := &in.Throttle, &out.Throttle
		*out = new(filter.Throttle)
		**out = **in
	}
	if in.SumoLogic != nil {
		in, out := &in.SumoLogic, &out.SumoLogic
		*out = new(filter.SumoLogic)
		(*in).DeepCopyInto(*out)
	}
	if in.EnhanceK8s != nil {
		in, out := &in.EnhanceK8s, &out.EnhanceK8s
		*out = new(filter.EnhanceK8s)
		(*in).DeepCopyInto(*out)
	}
	if in.KubeEventsTimestamp != nil {
		in, out := &in.KubeEventsTimestamp, &out.KubeEventsTimestamp
		*out = new(filter.KubeEventsTimestampConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Filter.
func (in *Filter) DeepCopy() *Filter {
	if in == nil {
		return nil
	}
	out := new(Filter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FilterAws) DeepCopyInto(out *FilterAws) {
	*out = *in
	if in.AZ != nil {
		in, out := &in.AZ, &out.AZ
		*out = new(bool)
		**out = **in
	}
	if in.Ec2InstanceID != nil {
		in, out := &in.Ec2InstanceID, &out.Ec2InstanceID
		*out = new(bool)
		**out = **in
	}
	if in.Ec2InstanceType != nil {
		in, out := &in.Ec2InstanceType, &out.Ec2InstanceType
		*out = new(bool)
		**out = **in
	}
	if in.PrivateIP != nil {
		in, out := &in.PrivateIP, &out.PrivateIP
		*out = new(bool)
		**out = **in
	}
	if in.AmiID != nil {
		in, out := &in.AmiID, &out.AmiID
		*out = new(bool)
		**out = **in
	}
	if in.AccountID != nil {
		in, out := &in.AccountID, &out.AccountID
		*out = new(bool)
		**out = **in
	}
	if in.Hostname != nil {
		in, out := &in.Hostname, &out.Hostname
		*out = new(bool)
		**out = **in
	}
	if in.VpcID != nil {
		in, out := &in.VpcID, &out.VpcID
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FilterAws.
func (in *FilterAws) DeepCopy() *FilterAws {
	if in == nil {
		return nil
	}
	out := new(FilterAws)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FilterKey) DeepCopyInto(out *FilterKey) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FilterKey.
func (in *FilterKey) DeepCopy() *FilterKey {
	if in == nil {
		return nil
	}
	out := new(FilterKey)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FilterKeyValue) DeepCopyInto(out *FilterKeyValue) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FilterKeyValue.
func (in *FilterKeyValue) DeepCopy() *FilterKeyValue {
	if in == nil {
		return nil
	}
	out := new(FilterKeyValue)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FilterKubernetes) DeepCopyInto(out *FilterKubernetes) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FilterKubernetes.
func (in *FilterKubernetes) DeepCopy() *FilterKubernetes {
	if in == nil {
		return nil
	}
	out := new(FilterKubernetes)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FilterModify) DeepCopyInto(out *FilterModify) {
	*out = *in
	if in.Rules != nil {
		in, out := &in.Rules, &out.Rules
		*out = make([]FilterModifyRule, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]FilterModifyCondition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FilterModify.
func (in *FilterModify) DeepCopy() *FilterModify {
	if in == nil {
		return nil
	}
	out := new(FilterModify)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FilterModifyCondition) DeepCopyInto(out *FilterModifyCondition) {
	*out = *in
	if in.KeyExists != nil {
		in, out := &in.KeyExists, &out.KeyExists
		*out = new(FilterKey)
		**out = **in
	}
	if in.KeyDoesNotExist != nil {
		in, out := &in.KeyDoesNotExist, &out.KeyDoesNotExist
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.AKeyMatches != nil {
		in, out := &in.AKeyMatches, &out.AKeyMatches
		*out = new(FilterKey)
		**out = **in
	}
	if in.NoKeyMatches != nil {
		in, out := &in.NoKeyMatches, &out.NoKeyMatches
		*out = new(FilterKey)
		**out = **in
	}
	if in.KeyValueEquals != nil {
		in, out := &in.KeyValueEquals, &out.KeyValueEquals
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.KeyValueDoesNotEqual != nil {
		in, out := &in.KeyValueDoesNotEqual, &out.KeyValueDoesNotEqual
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.KeyValueMatches != nil {
		in, out := &in.KeyValueMatches, &out.KeyValueMatches
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.KeyValueDoesNotMatch != nil {
		in, out := &in.KeyValueDoesNotMatch, &out.KeyValueDoesNotMatch
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.MatchingKeysHaveMatchingValues != nil {
		in, out := &in.MatchingKeysHaveMatchingValues, &out.MatchingKeysHaveMatchingValues
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.MatchingKeysDoNotHaveMatchingValues != nil {
		in, out := &in.MatchingKeysDoNotHaveMatchingValues, &out.MatchingKeysDoNotHaveMatchingValues
		*out = new(FilterKeyValue)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FilterModifyCondition.
func (in *FilterModifyCondition) DeepCopy() *FilterModifyCondition {
	if in == nil {
		return nil
	}
	out := new(FilterModifyCondition)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FilterModifyRule) DeepCopyInto(out *FilterModifyRule) {
	*out = *in
	if in.Set != nil {
		in, out := &in.Set, &out.Set
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.Add != nil {
		in, out := &in.Add, &out.Add
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.Remove != nil {
		in, out := &in.Remove, &out.Remove
		*out = new(FilterKey)
		**out = **in
	}
	if in.RemoveWildcard != nil {
		in, out := &in.RemoveWildcard, &out.RemoveWildcard
		*out = new(FilterKey)
		**out = **in
	}
	if in.RemoveRegex != nil {
		in, out := &in.RemoveRegex, &out.RemoveRegex
		*out = new(FilterKey)
		**out = **in
	}
	if in.Rename != nil {
		in, out := &in.Rename, &out.Rename
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.HardRename != nil {
		in, out := &in.HardRename, &out.HardRename
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.Copy != nil {
		in, out := &in.Copy, &out.Copy
		*out = new(FilterKeyValue)
		**out = **in
	}
	if in.HardCopy != nil {
		in, out := &in.HardCopy, &out.HardCopy
		*out = new(FilterKeyValue)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FilterModifyRule.
func (in *FilterModifyRule) DeepCopy() *FilterModifyRule {
	if in == nil {
		return nil
	}
	out := new(FilterModifyRule)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Flow) DeepCopyInto(out *Flow) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Flow.
func (in *Flow) DeepCopy() *Flow {
	if in == nil {
		return nil
	}
	out := new(Flow)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Flow) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FlowList) DeepCopyInto(out *FlowList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Flow, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FlowList.
func (in *FlowList) DeepCopy() *FlowList {
	if in == nil {
		return nil
	}
	out := new(FlowList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *FlowList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FlowSpec) DeepCopyInto(out *FlowSpec) {
	*out = *in
	if in.Selectors != nil {
		in, out := &in.Selectors, &out.Selectors
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Match != nil {
		in, out := &in.Match, &out.Match
		*out = make([]Match, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]Filter, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OutputRefs != nil {
		in, out := &in.OutputRefs, &out.OutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.GlobalOutputRefs != nil {
		in, out := &in.GlobalOutputRefs, &out.GlobalOutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.LocalOutputRefs != nil {
		in, out := &in.LocalOutputRefs, &out.LocalOutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FlowSpec.
func (in *FlowSpec) DeepCopy() *FlowSpec {
	if in == nil {
		return nil
	}
	out := new(FlowSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FlowStatus) DeepCopyInto(out *FlowStatus) {
	*out = *in
	if in.Active != nil {
		in, out := &in.Active, &out.Active
		*out = new(bool)
		**out = **in
	}
	if in.Problems != nil {
		in, out := &in.Problems, &out.Problems
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FlowStatus.
func (in *FlowStatus) DeepCopy() *FlowStatus {
	if in == nil {
		return nil
	}
	out := new(FlowStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentOutLogrotate) DeepCopyInto(out *FluentOutLogrotate) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentOutLogrotate.
func (in *FluentOutLogrotate) DeepCopy() *FluentOutLogrotate {
	if in == nil {
		return nil
	}
	out := new(FluentOutLogrotate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentbitNetwork) DeepCopyInto(out *FluentbitNetwork) {
	*out = *in
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(uint32)
		**out = **in
	}
	if in.ConnectTimeoutLogError != nil {
		in, out := &in.ConnectTimeoutLogError, &out.ConnectTimeoutLogError
		*out = new(bool)
		**out = **in
	}
	if in.DNSPreferIPV4 != nil {
		in, out := &in.DNSPreferIPV4, &out.DNSPreferIPV4
		*out = new(bool)
		**out = **in
	}
	if in.Keepalive != nil {
		in, out := &in.Keepalive, &out.Keepalive
		*out = new(bool)
		**out = **in
	}
	if in.KeepaliveIdleTimeout != nil {
		in, out := &in.KeepaliveIdleTimeout, &out.KeepaliveIdleTimeout
		*out = new(uint32)
		**out = **in
	}
	if in.KeepaliveMaxRecycle != nil {
		in, out := &in.KeepaliveMaxRecycle, &out.KeepaliveMaxRecycle
		*out = new(uint32)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentbitNetwork.
func (in *FluentbitNetwork) DeepCopy() *FluentbitNetwork {
	if in == nil {
		return nil
	}
	out := new(FluentbitNetwork)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentbitSpec) DeepCopyInto(out *FluentbitSpec) {
	*out = *in
	if in.DaemonSetAnnotations != nil {
		in, out := &in.DaemonSetAnnotations, &out.DaemonSetAnnotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.EnvVars != nil {
		in, out := &in.EnvVars, &out.EnvVars
		*out = make([]v1.EnvVar, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	in.Image.DeepCopyInto(&out.Image)
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(FluentbitTLS)
		(*in).DeepCopyInto(*out)
	}
	in.Resources.DeepCopyInto(&out.Resources)
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.NodeSelector != nil {
		in, out := &in.NodeSelector, &out.NodeSelector
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.Metrics != nil {
		in, out := &in.Metrics, &out.Metrics
		*out = new(Metrics)
		(*in).DeepCopyInto(*out)
	}
	if in.Security != nil {
		in, out := &in.Security, &out.Security
		*out = new(Security)
		(*in).DeepCopyInto(*out)
	}
	in.PositionDB.DeepCopyInto(&out.PositionDB)
	if in.PosisionDBLegacy != nil {
		in, out := &in.PosisionDBLegacy, &out.PosisionDBLegacy
		*out = new(volume.KubernetesVolume)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = make([]*VolumeMount, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(VolumeMount)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	in.InputTail.DeepCopyInto(&out.InputTail)
	if in.FilterAws != nil {
		in, out := &in.FilterAws, &out.FilterAws
		*out = new(FilterAws)
		(*in).DeepCopyInto(*out)
	}
	if in.FilterModify != nil {
		in, out := &in.FilterModify, &out.FilterModify
		*out = make([]FilterModify, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	out.FilterKubernetes = in.FilterKubernetes
	if in.DisableKubernetesFilter != nil {
		in, out := &in.DisableKubernetesFilter, &out.DisableKubernetesFilter
		*out = new(bool)
		**out = **in
	}
	out.BufferStorage = in.BufferStorage
	in.BufferStorageVolume.DeepCopyInto(&out.BufferStorageVolume)
	if in.BufferVolumeMetrics != nil {
		in, out := &in.BufferVolumeMetrics, &out.BufferVolumeMetrics
		*out = new(Metrics)
		(*in).DeepCopyInto(*out)
	}
	in.BufferVolumeImage.DeepCopyInto(&out.BufferVolumeImage)
	if in.BufferVolumeArgs != nil {
		in, out := &in.BufferVolumeArgs, &out.BufferVolumeArgs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.LivenessProbe != nil {
		in, out := &in.LivenessProbe, &out.LivenessProbe
		*out = new(v1.Probe)
		(*in).DeepCopyInto(*out)
	}
	if in.ReadinessProbe != nil {
		in, out := &in.ReadinessProbe, &out.ReadinessProbe
		*out = new(v1.Probe)
		(*in).DeepCopyInto(*out)
	}
	if in.Network != nil {
		in, out := &in.Network, &out.Network
		*out = new(FluentbitNetwork)
		(*in).DeepCopyInto(*out)
	}
	if in.ForwardOptions != nil {
		in, out := &in.ForwardOptions, &out.ForwardOptions
		*out = new(ForwardOptions)
		**out = **in
	}
	if in.ServiceAccountOverrides != nil {
		in, out := &in.ServiceAccountOverrides, &out.ServiceAccountOverrides
		*out = new(typeoverride.ServiceAccount)
		(*in).DeepCopyInto(*out)
	}
	if in.DNSConfig != nil {
		in, out := &in.DNSConfig, &out.DNSConfig
		*out = new(v1.PodDNSConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.SyslogNGOutput != nil {
		in, out := &in.SyslogNGOutput, &out.SyslogNGOutput
		*out = new(FluentbitTCPOutput)
		**out = **in
	}
	in.UpdateStrategy.DeepCopyInto(&out.UpdateStrategy)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentbitSpec.
func (in *FluentbitSpec) DeepCopy() *FluentbitSpec {
	if in == nil {
		return nil
	}
	out := new(FluentbitSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentbitTCPOutput) DeepCopyInto(out *FluentbitTCPOutput) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentbitTCPOutput.
func (in *FluentbitTCPOutput) DeepCopy() *FluentbitTCPOutput {
	if in == nil {
		return nil
	}
	out := new(FluentbitTCPOutput)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentbitTLS) DeepCopyInto(out *FluentbitTLS) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentbitTLS.
func (in *FluentbitTLS) DeepCopy() *FluentbitTLS {
	if in == nil {
		return nil
	}
	out := new(FluentbitTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentdDrainConfig) DeepCopyInto(out *FluentdDrainConfig) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	in.Image.DeepCopyInto(&out.Image)
	in.PauseImage.DeepCopyInto(&out.PauseImage)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentdDrainConfig.
func (in *FluentdDrainConfig) DeepCopy() *FluentdDrainConfig {
	if in == nil {
		return nil
	}
	out := new(FluentdDrainConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentdScaling) DeepCopyInto(out *FluentdScaling) {
	*out = *in
	in.Drain.DeepCopyInto(&out.Drain)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentdScaling.
func (in *FluentdScaling) DeepCopy() *FluentdScaling {
	if in == nil {
		return nil
	}
	out := new(FluentdScaling)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentdSpec) DeepCopyInto(out *FluentdSpec) {
	*out = *in
	if in.StatefulSetAnnotations != nil {
		in, out := &in.StatefulSetAnnotations, &out.StatefulSetAnnotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ConfigCheckAnnotations != nil {
		in, out := &in.ConfigCheckAnnotations, &out.ConfigCheckAnnotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.EnvVars != nil {
		in, out := &in.EnvVars, &out.EnvVars
		*out = make([]v1.EnvVar, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	out.TLS = in.TLS
	in.Image.DeepCopyInto(&out.Image)
	in.BufferStorageVolume.DeepCopyInto(&out.BufferStorageVolume)
	if in.ExtraVolumes != nil {
		in, out := &in.ExtraVolumes, &out.ExtraVolumes
		*out = make([]ExtraVolume, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.FluentdPvcSpec != nil {
		in, out := &in.FluentdPvcSpec, &out.FluentdPvcSpec
		*out = new(volume.KubernetesVolume)
		(*in).DeepCopyInto(*out)
	}
	in.VolumeModImage.DeepCopyInto(&out.VolumeModImage)
	in.ConfigReloaderImage.DeepCopyInto(&out.ConfigReloaderImage)
	in.Resources.DeepCopyInto(&out.Resources)
	in.ConfigCheckResources.DeepCopyInto(&out.ConfigCheckResources)
	in.ConfigReloaderResources.DeepCopyInto(&out.ConfigReloaderResources)
	if in.LivenessProbe != nil {
		in, out := &in.LivenessProbe, &out.LivenessProbe
		*out = new(v1.Probe)
		(*in).DeepCopyInto(*out)
	}
	if in.ReadinessProbe != nil {
		in, out := &in.ReadinessProbe, &out.ReadinessProbe
		*out = new(v1.Probe)
		(*in).DeepCopyInto(*out)
	}
	out.ReadinessDefaultCheck = in.ReadinessDefaultCheck
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.NodeSelector != nil {
		in, out := &in.NodeSelector, &out.NodeSelector
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.TopologySpreadConstraints != nil {
		in, out := &in.TopologySpreadConstraints, &out.TopologySpreadConstraints
		*out = make([]v1.TopologySpreadConstraint, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metrics != nil {
		in, out := &in.Metrics, &out.Metrics
		*out = new(Metrics)
		(*in).DeepCopyInto(*out)
	}
	if in.BufferVolumeMetrics != nil {
		in, out := &in.BufferVolumeMetrics, &out.BufferVolumeMetrics
		*out = new(Metrics)
		(*in).DeepCopyInto(*out)
	}
	in.BufferVolumeImage.DeepCopyInto(&out.BufferVolumeImage)
	if in.BufferVolumeArgs != nil {
		in, out := &in.BufferVolumeArgs, &out.BufferVolumeArgs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Security != nil {
		in, out := &in.Security, &out.Security
		*out = new(Security)
		(*in).DeepCopyInto(*out)
	}
	if in.Scaling != nil {
		in, out := &in.Scaling, &out.Scaling
		*out = new(FluentdScaling)
		(*in).DeepCopyInto(*out)
	}
	if in.FluentOutLogrotate != nil {
		in, out := &in.FluentOutLogrotate, &out.FluentOutLogrotate
		*out = new(FluentOutLogrotate)
		**out = **in
	}
	if in.ForwardInputConfig != nil {
		in, out := &in.ForwardInputConfig, &out.ForwardInputConfig
		*out = new(input.ForwardInputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceAccountOverrides != nil {
		in, out := &in.ServiceAccountOverrides, &out.ServiceAccountOverrides
		*out = new(typeoverride.ServiceAccount)
		(*in).DeepCopyInto(*out)
	}
	if in.DNSConfig != nil {
		in, out := &in.DNSConfig, &out.DNSConfig
		*out = new(v1.PodDNSConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.ExtraArgs != nil {
		in, out := &in.ExtraArgs, &out.ExtraArgs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentdSpec.
func (in *FluentdSpec) DeepCopy() *FluentdSpec {
	if in == nil {
		return nil
	}
	out := new(FluentdSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentdTLS) DeepCopyInto(out *FluentdTLS) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentdTLS.
func (in *FluentdTLS) DeepCopy() *FluentdTLS {
	if in == nil {
		return nil
	}
	out := new(FluentdTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ForwardOptions) DeepCopyInto(out *ForwardOptions) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ForwardOptions.
func (in *ForwardOptions) DeepCopy() *ForwardOptions {
	if in == nil {
		return nil
	}
	out := new(ForwardOptions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GlobalOptions) DeepCopyInto(out *GlobalOptions) {
	*out = *in
	if in.StatsLevel != nil {
		in, out := &in.StatsLevel, &out.StatsLevel
		*out = new(int)
		**out = **in
	}
	if in.StatsFreq != nil {
		in, out := &in.StatsFreq, &out.StatsFreq
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GlobalOptions.
func (in *GlobalOptions) DeepCopy() *GlobalOptions {
	if in == nil {
		return nil
	}
	out := new(GlobalOptions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ImageSpec) DeepCopyInto(out *ImageSpec) {
	*out = *in
	if in.ImagePullSecrets != nil {
		in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
		*out = make([]v1.LocalObjectReference, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ImageSpec.
func (in *ImageSpec) DeepCopy() *ImageSpec {
	if in == nil {
		return nil
	}
	out := new(ImageSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InputTail) DeepCopyInto(out *InputTail) {
	*out = *in
	if in.DB != nil {
		in, out := &in.DB, &out.DB
		*out = new(string)
		**out = **in
	}
	if in.DBLocking != nil {
		in, out := &in.DBLocking, &out.DBLocking
		*out = new(bool)
		**out = **in
	}
	if in.ParserN != nil {
		in, out := &in.ParserN, &out.ParserN
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.MultilineParser != nil {
		in, out := &in.MultilineParser, &out.MultilineParser
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InputTail.
func (in *InputTail) DeepCopy() *InputTail {
	if in == nil {
		return nil
	}
	out := new(InputTail)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Logging) DeepCopyInto(out *Logging) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Logging.
func (in *Logging) DeepCopy() *Logging {
	if in == nil {
		return nil
	}
	out := new(Logging)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Logging) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingList) DeepCopyInto(out *LoggingList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Logging, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingList.
func (in *LoggingList) DeepCopy() *LoggingList {
	if in == nil {
		return nil
	}
	out := new(LoggingList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LoggingList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingSpec) DeepCopyInto(out *LoggingSpec) {
	*out = *in
	if in.FluentbitSpec != nil {
		in, out := &in.FluentbitSpec, &out.FluentbitSpec
		*out = new(FluentbitSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.FluentdSpec != nil {
		in, out := &in.FluentdSpec, &out.FluentdSpec
		*out = new(FluentdSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.SyslogNGSpec != nil {
		in, out := &in.SyslogNGSpec, &out.SyslogNGSpec
		*out = new(SyslogNGSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.DefaultFlowSpec != nil {
		in, out := &in.DefaultFlowSpec, &out.DefaultFlowSpec
		*out = new(DefaultFlowSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.GlobalFilters != nil {
		in, out := &in.GlobalFilters, &out.GlobalFilters
		*out = make([]Filter, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.WatchNamespaces != nil {
		in, out := &in.WatchNamespaces, &out.WatchNamespaces
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ClusterDomain != nil {
		in, out := &in.ClusterDomain, &out.ClusterDomain
		*out = new(string)
		**out = **in
	}
	if in.NodeAgents != nil {
		in, out := &in.NodeAgents, &out.NodeAgents
		*out = make([]*NodeAgent, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(NodeAgent)
				(*in).DeepCopyInto(*out)
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingSpec.
func (in *LoggingSpec) DeepCopy() *LoggingSpec {
	if in == nil {
		return nil
	}
	out := new(LoggingSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingStatus) DeepCopyInto(out *LoggingStatus) {
	*out = *in
	if in.ConfigCheckResults != nil {
		in, out := &in.ConfigCheckResults, &out.ConfigCheckResults
		*out = make(map[string]bool, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingStatus.
func (in *LoggingStatus) DeepCopy() *LoggingStatus {
	if in == nil {
		return nil
	}
	out := new(LoggingStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Match) DeepCopyInto(out *Match) {
	*out = *in
	if in.Select != nil {
		in, out := &in.Select, &out.Select
		*out = new(Select)
		(*in).DeepCopyInto(*out)
	}
	if in.Exclude != nil {
		in, out := &in.Exclude, &out.Exclude
		*out = new(Exclude)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Match.
func (in *Match) DeepCopy() *Match {
	if in == nil {
		return nil
	}
	out := new(Match)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Metrics) DeepCopyInto(out *Metrics) {
	*out = *in
	in.ServiceMonitorConfig.DeepCopyInto(&out.ServiceMonitorConfig)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Metrics.
func (in *Metrics) DeepCopy() *Metrics {
	if in == nil {
		return nil
	}
	out := new(Metrics)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeAgent) DeepCopyInto(out *NodeAgent) {
	*out = *in
	in.Metadata.DeepCopyInto(&out.Metadata)
	if in.FluentbitSpec != nil {
		in, out := &in.FluentbitSpec, &out.FluentbitSpec
		*out = new(NodeAgentFluentbit)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeAgent.
func (in *NodeAgent) DeepCopy() *NodeAgent {
	if in == nil {
		return nil
	}
	out := new(NodeAgent)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeAgentFluentbit) DeepCopyInto(out *NodeAgentFluentbit) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.DaemonSetOverrides != nil {
		in, out := &in.DaemonSetOverrides, &out.DaemonSetOverrides
		*out = new(typeoverride.DaemonSet)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceAccountOverrides != nil {
		in, out := &in.ServiceAccountOverrides, &out.ServiceAccountOverrides
		*out = new(typeoverride.ServiceAccount)
		(*in).DeepCopyInto(*out)
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(FluentbitTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.Metrics != nil {
		in, out := &in.Metrics, &out.Metrics
		*out = new(Metrics)
		(*in).DeepCopyInto(*out)
	}
	if in.MetricsService != nil {
		in, out := &in.MetricsService, &out.MetricsService
		*out = new(typeoverride.Service)
		(*in).DeepCopyInto(*out)
	}
	if in.Security != nil {
		in, out := &in.Security, &out.Security
		*out = new(Security)
		(*in).DeepCopyInto(*out)
	}
	in.PositionDB.DeepCopyInto(&out.PositionDB)
	if in.ExtraVolumeMounts != nil {
		in, out := &in.ExtraVolumeMounts, &out.ExtraVolumeMounts
		*out = make([]*VolumeMount, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(VolumeMount)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	in.InputTail.DeepCopyInto(&out.InputTail)
	if in.FilterAws != nil {
		in, out := &in.FilterAws, &out.FilterAws
		*out = new(FilterAws)
		(*in).DeepCopyInto(*out)
	}
	out.FilterKubernetes = in.FilterKubernetes
	if in.DisableKubernetesFilter != nil {
		in, out := &in.DisableKubernetesFilter, &out.DisableKubernetesFilter
		*out = new(bool)
		**out = **in
	}
	out.BufferStorage = in.BufferStorage
	in.BufferStorageVolume.DeepCopyInto(&out.BufferStorageVolume)
	if in.LivenessDefaultCheck != nil {
		in, out := &in.LivenessDefaultCheck, &out.LivenessDefaultCheck
		*out = new(bool)
		**out = **in
	}
	if in.Network != nil {
		in, out := &in.Network, &out.Network
		*out = new(FluentbitNetwork)
		(*in).DeepCopyInto(*out)
	}
	if in.ForwardOptions != nil {
		in, out := &in.ForwardOptions, &out.ForwardOptions
		*out = new(ForwardOptions)
		**out = **in
	}
	if in.EnableUpstream != nil {
		in, out := &in.EnableUpstream, &out.EnableUpstream
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeAgentFluentbit.
func (in *NodeAgentFluentbit) DeepCopy() *NodeAgentFluentbit {
	if in == nil {
		return nil
	}
	out := new(NodeAgentFluentbit)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Operation) DeepCopyInto(out *Operation) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Operation.
func (in *Operation) DeepCopy() *Operation {
	if in == nil {
		return nil
	}
	out := new(Operation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Output) DeepCopyInto(out *Output) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Output.
func (in *Output) DeepCopy() *Output {
	if in == nil {
		return nil
	}
	out := new(Output)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Output) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OutputList) DeepCopyInto(out *OutputList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Output, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OutputList.
func (in *OutputList) DeepCopy() *OutputList {
	if in == nil {
		return nil
	}
	out := new(OutputList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OutputList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OutputSpec) DeepCopyInto(out *OutputSpec) {
	*out = *in
	if in.S3OutputConfig != nil {
		in, out := &in.S3OutputConfig, &out.S3OutputConfig
		*out = new(output.S3OutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.AzureStorage != nil {
		in, out := &in.AzureStorage, &out.AzureStorage
		*out = new(output.AzureStorage)
		(*in).DeepCopyInto(*out)
	}
	if in.GCSOutput != nil {
		in, out := &in.GCSOutput, &out.GCSOutput
		*out = new(output.GCSOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.OSSOutput != nil {
		in, out := &in.OSSOutput, &out.OSSOutput
		*out = new(output.OSSOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.ElasticsearchOutput != nil {
		in, out := &in.ElasticsearchOutput, &out.ElasticsearchOutput
		*out = new(output.ElasticsearchOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.OpenSearchOutput != nil {
		in, out := &in.OpenSearchOutput, &out.OpenSearchOutput
		*out = new(output.OpenSearchOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.LogZOutput != nil {
		in, out := &in.LogZOutput, &out.LogZOutput
		*out = new(output.LogZOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.LokiOutput != nil {
		in, out := &in.LokiOutput, &out.LokiOutput
		*out = new(output.LokiOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.SumologicOutput != nil {
		in, out := &in.SumologicOutput, &out.SumologicOutput
		*out = new(output.SumologicOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.DatadogOutput != nil {
		in, out := &in.DatadogOutput, &out.DatadogOutput
		*out = new(output.DatadogOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.ForwardOutput != nil {
		in, out := &in.ForwardOutput, &out.ForwardOutput
		*out = new(output.ForwardOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.FileOutput != nil {
		in, out := &in.FileOutput, &out.FileOutput
		*out = new(output.FileOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.NullOutputConfig != nil {
		in, out := &in.NullOutputConfig, &out.NullOutputConfig
		*out = new(output.NullOutputConfig)
		**out = **in
	}
	if in.KafkaOutputConfig != nil {
		in, out := &in.KafkaOutputConfig, &out.KafkaOutputConfig
		*out = new(output.KafkaOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.CloudWatchOutput != nil {
		in, out := &in.CloudWatchOutput, &out.CloudWatchOutput
		*out = new(output.CloudWatchOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.KinesisStreamOutputConfig != nil {
		in, out := &in.KinesisStreamOutputConfig, &out.KinesisStreamOutputConfig
		*out = new(output.KinesisStreamOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.LogDNAOutput != nil {
		in, out := &in.LogDNAOutput, &out.LogDNAOutput
		*out = new(output.LogDNAOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.NewRelicOutputConfig != nil {
		in, out := &in.NewRelicOutputConfig, &out.NewRelicOutputConfig
		*out = new(output.NewRelicOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.SplunkHecOutput != nil {
		in, out := &in.SplunkHecOutput, &out.SplunkHecOutput
		*out = new(output.SplunkHecOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.HTTPOutput != nil {
		in, out := &in.HTTPOutput, &out.HTTPOutput
		*out = new(output.HTTPOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.AwsElasticsearchOutputConfig != nil {
		in, out := &in.AwsElasticsearchOutputConfig, &out.AwsElasticsearchOutputConfig
		*out = new(output.AwsElasticsearchOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.RedisOutputConfig != nil {
		in, out := &in.RedisOutputConfig, &out.RedisOutputConfig
		*out = new(output.RedisOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.SyslogOutputConfig != nil {
		in, out := &in.SyslogOutputConfig, &out.SyslogOutputConfig
		*out = new(output.SyslogOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.GELFOutputConfig != nil {
		in, out := &in.GELFOutputConfig, &out.GELFOutputConfig
		*out = new(output.GELFOutputConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.SQSOutputConfig != nil {
		in, out := &in.SQSOutputConfig, &out.SQSOutputConfig
		*out = new(output.SQSOutputConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OutputSpec.
func (in *OutputSpec) DeepCopy() *OutputSpec {
	if in == nil {
		return nil
	}
	out := new(OutputSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OutputStatus) DeepCopyInto(out *OutputStatus) {
	*out = *in
	if in.Active != nil {
		in, out := &in.Active, &out.Active
		*out = new(bool)
		**out = **in
	}
	if in.Problems != nil {
		in, out := &in.Problems, &out.Problems
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OutputStatus.
func (in *OutputStatus) DeepCopy() *OutputStatus {
	if in == nil {
		return nil
	}
	out := new(OutputStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReadinessDefaultCheck) DeepCopyInto(out *ReadinessDefaultCheck) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReadinessDefaultCheck.
func (in *ReadinessDefaultCheck) DeepCopy() *ReadinessDefaultCheck {
	if in == nil {
		return nil
	}
	out := new(ReadinessDefaultCheck)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Security) DeepCopyInto(out *Security) {
	*out = *in
	if in.RoleBasedAccessControlCreate != nil {
		in, out := &in.RoleBasedAccessControlCreate, &out.RoleBasedAccessControlCreate
		*out = new(bool)
		**out = **in
	}
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(v1.SecurityContext)
		(*in).DeepCopyInto(*out)
	}
	if in.PodSecurityContext != nil {
		in, out := &in.PodSecurityContext, &out.PodSecurityContext
		*out = new(v1.PodSecurityContext)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Security.
func (in *Security) DeepCopy() *Security {
	if in == nil {
		return nil
	}
	out := new(Security)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Select) DeepCopyInto(out *Select) {
	*out = *in
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Hosts != nil {
		in, out := &in.Hosts, &out.Hosts
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ContainerNames != nil {
		in, out := &in.ContainerNames, &out.ContainerNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Select.
func (in *Select) DeepCopy() *Select {
	if in == nil {
		return nil
	}
	out := new(Select)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceMonitorConfig) DeepCopyInto(out *ServiceMonitorConfig) {
	*out = *in
	if in.AdditionalLabels != nil {
		in, out := &in.AdditionalLabels, &out.AdditionalLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Relabelings != nil {
		in, out := &in.Relabelings, &out.Relabelings
		*out = make([]*monitoringv1.RelabelConfig, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(monitoringv1.RelabelConfig)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.MetricsRelabelings != nil {
		in, out := &in.MetricsRelabelings, &out.MetricsRelabelings
		*out = make([]*monitoringv1.RelabelConfig, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(monitoringv1.RelabelConfig)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.TLSConfig != nil {
		in, out := &in.TLSConfig, &out.TLSConfig
		*out = new(monitoringv1.TLSConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceMonitorConfig.
func (in *ServiceMonitorConfig) DeepCopy() *ServiceMonitorConfig {
	if in == nil {
		return nil
	}
	out := new(ServiceMonitorConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGClusterFlow) DeepCopyInto(out *SyslogNGClusterFlow) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGClusterFlow.
func (in *SyslogNGClusterFlow) DeepCopy() *SyslogNGClusterFlow {
	if in == nil {
		return nil
	}
	out := new(SyslogNGClusterFlow)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SyslogNGClusterFlow) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGClusterFlowList) DeepCopyInto(out *SyslogNGClusterFlowList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SyslogNGClusterFlow, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGClusterFlowList.
func (in *SyslogNGClusterFlowList) DeepCopy() *SyslogNGClusterFlowList {
	if in == nil {
		return nil
	}
	out := new(SyslogNGClusterFlowList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SyslogNGClusterFlowList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGClusterFlowSpec) DeepCopyInto(out *SyslogNGClusterFlowSpec) {
	*out = *in
	if in.Match != nil {
		in, out := &in.Match, &out.Match
		*out = new(SyslogNGMatch)
		(*in).DeepCopyInto(*out)
	}
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]SyslogNGFilter, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.GlobalOutputRefs != nil {
		in, out := &in.GlobalOutputRefs, &out.GlobalOutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGClusterFlowSpec.
func (in *SyslogNGClusterFlowSpec) DeepCopy() *SyslogNGClusterFlowSpec {
	if in == nil {
		return nil
	}
	out := new(SyslogNGClusterFlowSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGClusterMatch) DeepCopyInto(out *SyslogNGClusterMatch) {
	*out = *in
	if in.And != nil {
		in, out := &in.And, &out.And
		*out = make([]syslogngfilter.MatchExpr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Not != nil {
		in, out := &in.Not, &out.Not
		*out = new(syslogngfilter.MatchExpr)
		(*in).DeepCopyInto(*out)
	}
	if in.Regexp != nil {
		in, out := &in.Regexp, &out.Regexp
		*out = new(syslogngfilter.RegexpMatchExpr)
		(*in).DeepCopyInto(*out)
	}
	if in.Or != nil {
		in, out := &in.Or, &out.Or
		*out = make([]syslogngfilter.MatchExpr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGClusterMatch.
func (in *SyslogNGClusterMatch) DeepCopy() *SyslogNGClusterMatch {
	if in == nil {
		return nil
	}
	out := new(SyslogNGClusterMatch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGClusterOutput) DeepCopyInto(out *SyslogNGClusterOutput) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGClusterOutput.
func (in *SyslogNGClusterOutput) DeepCopy() *SyslogNGClusterOutput {
	if in == nil {
		return nil
	}
	out := new(SyslogNGClusterOutput)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SyslogNGClusterOutput) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGClusterOutputList) DeepCopyInto(out *SyslogNGClusterOutputList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SyslogNGClusterOutput, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGClusterOutputList.
func (in *SyslogNGClusterOutputList) DeepCopy() *SyslogNGClusterOutputList {
	if in == nil {
		return nil
	}
	out := new(SyslogNGClusterOutputList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SyslogNGClusterOutputList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGClusterOutputSpec) DeepCopyInto(out *SyslogNGClusterOutputSpec) {
	*out = *in
	in.SyslogNGOutputSpec.DeepCopyInto(&out.SyslogNGOutputSpec)
	if in.EnabledNamespaces != nil {
		in, out := &in.EnabledNamespaces, &out.EnabledNamespaces
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGClusterOutputSpec.
func (in *SyslogNGClusterOutputSpec) DeepCopy() *SyslogNGClusterOutputSpec {
	if in == nil {
		return nil
	}
	out := new(SyslogNGClusterOutputSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGFilter) DeepCopyInto(out *SyslogNGFilter) {
	*out = *in
	if in.Match != nil {
		in, out := &in.Match, &out.Match
		*out = new(syslogngfilter.MatchConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.Rewrite != nil {
		in, out := &in.Rewrite, &out.Rewrite
		*out = make([]syslogngfilter.RewriteConfig, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Parser != nil {
		in, out := &in.Parser, &out.Parser
		*out = new(syslogngfilter.ParserConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGFilter.
func (in *SyslogNGFilter) DeepCopy() *SyslogNGFilter {
	if in == nil {
		return nil
	}
	out := new(SyslogNGFilter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGFlow) DeepCopyInto(out *SyslogNGFlow) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGFlow.
func (in *SyslogNGFlow) DeepCopy() *SyslogNGFlow {
	if in == nil {
		return nil
	}
	out := new(SyslogNGFlow)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SyslogNGFlow) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGFlowList) DeepCopyInto(out *SyslogNGFlowList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SyslogNGFlow, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGFlowList.
func (in *SyslogNGFlowList) DeepCopy() *SyslogNGFlowList {
	if in == nil {
		return nil
	}
	out := new(SyslogNGFlowList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SyslogNGFlowList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGFlowSpec) DeepCopyInto(out *SyslogNGFlowSpec) {
	*out = *in
	if in.Match != nil {
		in, out := &in.Match, &out.Match
		*out = new(SyslogNGMatch)
		(*in).DeepCopyInto(*out)
	}
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]SyslogNGFilter, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.GlobalOutputRefs != nil {
		in, out := &in.GlobalOutputRefs, &out.GlobalOutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.LocalOutputRefs != nil {
		in, out := &in.LocalOutputRefs, &out.LocalOutputRefs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGFlowSpec.
func (in *SyslogNGFlowSpec) DeepCopy() *SyslogNGFlowSpec {
	if in == nil {
		return nil
	}
	out := new(SyslogNGFlowSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGFlowStatus) DeepCopyInto(out *SyslogNGFlowStatus) {
	*out = *in
	if in.Active != nil {
		in, out := &in.Active, &out.Active
		*out = new(bool)
		**out = **in
	}
	if in.Problems != nil {
		in, out := &in.Problems, &out.Problems
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGFlowStatus.
func (in *SyslogNGFlowStatus) DeepCopy() *SyslogNGFlowStatus {
	if in == nil {
		return nil
	}
	out := new(SyslogNGFlowStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGMatch) DeepCopyInto(out *SyslogNGMatch) {
	*out = *in
	if in.And != nil {
		in, out := &in.And, &out.And
		*out = make([]syslogngfilter.MatchExpr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Not != nil {
		in, out := &in.Not, &out.Not
		*out = new(syslogngfilter.MatchExpr)
		(*in).DeepCopyInto(*out)
	}
	if in.Regexp != nil {
		in, out := &in.Regexp, &out.Regexp
		*out = new(syslogngfilter.RegexpMatchExpr)
		(*in).DeepCopyInto(*out)
	}
	if in.Or != nil {
		in, out := &in.Or, &out.Or
		*out = make([]syslogngfilter.MatchExpr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGMatch.
func (in *SyslogNGMatch) DeepCopy() *SyslogNGMatch {
	if in == nil {
		return nil
	}
	out := new(SyslogNGMatch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGOutput) DeepCopyInto(out *SyslogNGOutput) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGOutput.
func (in *SyslogNGOutput) DeepCopy() *SyslogNGOutput {
	if in == nil {
		return nil
	}
	out := new(SyslogNGOutput)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SyslogNGOutput) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGOutputList) DeepCopyInto(out *SyslogNGOutputList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SyslogNGOutput, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGOutputList.
func (in *SyslogNGOutputList) DeepCopy() *SyslogNGOutputList {
	if in == nil {
		return nil
	}
	out := new(SyslogNGOutputList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SyslogNGOutputList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGOutputSpec) DeepCopyInto(out *SyslogNGOutputSpec) {
	*out = *in
	if in.Loggly != nil {
		in, out := &in.Loggly, &out.Loggly
		*out = new(syslogngoutput.Loggly)
		(*in).DeepCopyInto(*out)
	}
	if in.Syslog != nil {
		in, out := &in.Syslog, &out.Syslog
		*out = new(syslogngoutput.SyslogOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.File != nil {
		in, out := &in.File, &out.File
		*out = new(syslogngoutput.FileOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.SumologicHTTP != nil {
		in, out := &in.SumologicHTTP, &out.SumologicHTTP
		*out = new(syslogngoutput.SumologicHTTPOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.SumologicSyslog != nil {
		in, out := &in.SumologicSyslog, &out.SumologicSyslog
		*out = new(syslogngoutput.SumologicSyslogOutput)
		(*in).DeepCopyInto(*out)
	}
	if in.HTTP != nil {
		in, out := &in.HTTP, &out.HTTP
		*out = new(syslogngoutput.HTTPOutput)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGOutputSpec.
func (in *SyslogNGOutputSpec) DeepCopy() *SyslogNGOutputSpec {
	if in == nil {
		return nil
	}
	out := new(SyslogNGOutputSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGOutputStatus) DeepCopyInto(out *SyslogNGOutputStatus) {
	*out = *in
	if in.Active != nil {
		in, out := &in.Active, &out.Active
		*out = new(bool)
		**out = **in
	}
	if in.Problems != nil {
		in, out := &in.Problems, &out.Problems
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGOutputStatus.
func (in *SyslogNGOutputStatus) DeepCopy() *SyslogNGOutputStatus {
	if in == nil {
		return nil
	}
	out := new(SyslogNGOutputStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGSpec) DeepCopyInto(out *SyslogNGSpec) {
	*out = *in
	out.TLS = in.TLS
	out.ReadinessDefaultCheck = in.ReadinessDefaultCheck
	if in.StatefulSetOverrides != nil {
		in, out := &in.StatefulSetOverrides, &out.StatefulSetOverrides
		*out = new(typeoverride.StatefulSet)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceOverrides != nil {
		in, out := &in.ServiceOverrides, &out.ServiceOverrides
		*out = new(typeoverride.Service)
		(*in).DeepCopyInto(*out)
	}
	if in.ServiceAccountOverrides != nil {
		in, out := &in.ServiceAccountOverrides, &out.ServiceAccountOverrides
		*out = new(typeoverride.ServiceAccount)
		(*in).DeepCopyInto(*out)
	}
	if in.ConfigCheckPodOverrides != nil {
		in, out := &in.ConfigCheckPodOverrides, &out.ConfigCheckPodOverrides
		*out = new(typeoverride.PodSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Metrics != nil {
		in, out := &in.Metrics, &out.Metrics
		*out = new(Metrics)
		(*in).DeepCopyInto(*out)
	}
	if in.MetricsServiceOverrides != nil {
		in, out := &in.MetricsServiceOverrides, &out.MetricsServiceOverrides
		*out = new(typeoverride.Service)
		(*in).DeepCopyInto(*out)
	}
	if in.BufferVolumeMetrics != nil {
		in, out := &in.BufferVolumeMetrics, &out.BufferVolumeMetrics
		*out = new(BufferMetrics)
		(*in).DeepCopyInto(*out)
	}
	if in.BufferVolumeMetricsServiceOverrides != nil {
		in, out := &in.BufferVolumeMetricsServiceOverrides, &out.BufferVolumeMetricsServiceOverrides
		*out = new(typeoverride.Service)
		(*in).DeepCopyInto(*out)
	}
	if in.GlobalOptions != nil {
		in, out := &in.GlobalOptions, &out.GlobalOptions
		*out = new(GlobalOptions)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGSpec.
func (in *SyslogNGSpec) DeepCopy() *SyslogNGSpec {
	if in == nil {
		return nil
	}
	out := new(SyslogNGSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SyslogNGTLS) DeepCopyInto(out *SyslogNGTLS) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SyslogNGTLS.
func (in *SyslogNGTLS) DeepCopy() *SyslogNGTLS {
	if in == nil {
		return nil
	}
	out := new(SyslogNGTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VolumeMount) DeepCopyInto(out *VolumeMount) {
	*out = *in
	if in.ReadOnly != nil {
		in, out := &in.ReadOnly, &out.ReadOnly
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VolumeMount.
func (in *VolumeMount) DeepCopy() *VolumeMount {
	if in == nil {
		return nil
	}
	out := new(VolumeMount)
	in.DeepCopyInto(out)
	return out
}
